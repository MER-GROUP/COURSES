# считываем всё из stdin
ввод <- scan('stdin', quiet=T)
v <- ввод[1]
e <- ввод[2]

массив <- matrix(ввод[-c(1, 2)], ncol=2, byrow=T)

# список вершин, содержащий соседей данной вершины
вершины <- vector(mode="list", length=v)

# заполняем список вершин
for (i in seq_len(e)) {
  вершины[[массив[i,1]]] <- c(вершины[[массив[i,1]]], массив[i,2])
  вершины[[массив[i,2]]] <- c(вершины[[массив[i,2]]], массив[i,1])
}

# предварительная проверка
none <- function() { cat("NONE\n"); q("no") }
if (any(sapply(вершины, length) < 2) ||
    any(sapply(вершины, length) %% 2 != 0)) none()

# начальные значения для стека и результата
стек <- 1
результат <- c()

# цикл пока в стеке что-то есть
while (length(стек) > 0) {
  # верхушка стека
  в.стека <- стек[length(стек)]
  # если у верхушки стека нет соседей
  if (length(вершины[[в.стека]]) == 0) {
    # то добавляем её к результату
    результат <- c(результат, в.стека)
    # и убираем из стека
    стек <- стек[-length(стек)]
  } else {
    # если есть соседи, то берём первого соседа
    следующая <- вершины[[в.стека]][1]
    # удаляем его из списка соседей
    вершины[[в.стека]] <- вершины[[в.стека]][-1]
    # также удаляем вершину, являющуюся верхушкой стека,
    # из списка соседей для выбранной вершины
    вершины[[следующая]] <-
      вершины[[следующая]][-which(вершины[[следующая]] == в.стека)[1]]
    # выбранную вершину добавляем в стек
    стек <- c(стек, следующая)
  }
}

# проверка, что вернулись в ту же первую вершину
# и что не осталось «неразобранных» вершин
if (результат[1] != результат[length(результат)] ||
    any(sapply(вершины, length) != 0)) none()

# выводим результат, убрав дубль первой вершины
cat(результат[-length(результат)])
cat("\n")