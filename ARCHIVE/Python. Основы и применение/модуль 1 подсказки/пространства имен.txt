В принципе подъёмная задача ) Я конечно пол дня потратил на решение... Но вот теперь когда смотрю на решение, мне даже кажется, что не особо и сложная ) На написание самого кода ушло не так уж много времени, когда понял алгоритм решения.



Основные две трудности, которые встретились. B каком виде хранить данные? Как реализовать функцию get?



1. Данные. Допустим изначально это будет словарь. Тут стоит пристальное внимание обратить на то, что имена неймспейсов уникальные! А значит если каждая отдельная 'запись'  будет знать свой неймспейс и неймспейс родителя, то структуру типа:



Неймспейс: родительский неймспейс.
'global': None...
'foo': 'global'...
'bar': 'foo'...
'biz': 'bar'...

мы сможем 'отмотать' назад из исходной точки, не боясь, что находимся не в той ветке. При этом вообще не важно в какой последовательности эти записи вносились. Ну и конечно каждая запись должна ещё и сами переменные хранить. Теперь как отматывать ? А отматывать будет тот самый get.



2. get. Вообще тут создателями урока дана большая подсказка. Точнее прямо написано как этот get должен работать )

В тексте задания написано: 

Более формально, результатом работы get <namespace> <var> является... [Дальше идёт описание]. 



И оказывается, что этот алгоритм (да, да, именно здесь будет рекурсия) отлично ложится на структуру в которой каждая запись знает - текущий неймспейс, родительский неймспейс, имена переменных в текущем неймспейсе. Я реализовал его практически дословно. Получился один блок if ... elif ... else.



Всем удачи !: )

Судя из описания задачи, сами авторы подразумевали рекурсию в реализации функции get.

Более формально, результатом работы get <namespace> <var> является

- <namespace>, если в пространстве <namespace> была объявлена переменная <var>
- get <parent> <var> – результат запроса к пространству, внутри которого было создано пространство <namespace>, если переменная не была объявлена
- None, если не существует <parent>, т. е. <namespace>﻿ – это global
То есть если не находим переменную в текущем неймспейсе, то по рекурсии вызываем get только уже передавая ему родителя текущего неймспейса.
ЗЫ: естественно для такой реализации надо 'запоминать', кто является родителем текущего неймспейса.