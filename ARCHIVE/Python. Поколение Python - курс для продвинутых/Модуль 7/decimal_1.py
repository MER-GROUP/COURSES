# Тип данных float - число с плавающей точкой (аналог вещественного числа в математике).
print('********************')
if 0.3 == 0.3:
    print('YES')
else:
    print('NO')
print('********************')
num = 0.1 + 0.1 + 0.1
if num == 0.3:
    print('YES')
else:
    print('NO')
    
# сравнение float чисел
print('********************')
num = 0.1 + 0.1 + 0.1
# точность сравнения
eps = 0.000000001
# число num отличается от числа 0.3 менее чем 0.000000001
if abs(num - 0.3) < eps:
    print('YES')
else:
    print('NO')
# Не стоит сравнивать float числа с помощью оператора ==. Для сравнения float чисел нужно использовать указанный выше код.

# Тип данных Decimal - десятичное число, для выполнения точных расчетов; это класс из стандартного модуля decimal. Он представляет собой число с плавающей точкой, как и float.

# Тип Decimal создан, чтобы операции над вещественными числами в компьютере выполнялись как в математике, и равенство 0.1 + 0.1 + 0.1 == 0.30.1+0.1+0.1==0.3 было верным.

# В Python тип данных float реализован по стандарту IEEE-754 как число с плавающей точкой двойной точности (6464 бита) с основанием экспоненты равным 22. Реализация таких чисел заложена прямо в железо любого современного процессора. Поэтому float в Python работает как аналогичный тип данных double в таких языках программирования как С#, С++, Java и т.д. И имеет такие же ограничения и «странности». Так как float поддерживается аппаратно, быстродействие при использовании этого типа данных сравнительно велико.

# Тип данных Decimal – число с плавающей точкой с основанием экспоненты 1010. Он реализован по стандарту IBM: General Decimal Arithmetic Specification, в свою очередь основанному на стандартах IEEE.

# Тип данных Decimal реализован программно, поэтому он в разы медленнее типа данных float, реализованного аппаратно. Сам тип данных Decimal написан на языке С.

# Тип данных Decimal оперирует числами с произвольной – задаваемой программистом, но конечной точностью. По умолчанию точность составляет 28 десятичных знаков.

# Тип данных Decimal неизменяемый. Операции над ним приводят к созданию новых объектов, при этом старые не меняются.

# Еще одно следствие того, что Decimal реализован программно – его можно на ходу настраивать, как угодно программисту. Для этого есть контекст – объект, содержащий настройки для выполнения операций. Операции, выполняемые в контексте, следуют заданным в нем правилам. Для float все правила фиксированы на аппаратном уровне.

'''
Для типа данных Decimal можно настроить:

	точность выполнения операций в 		количестве десятичных знаков;
	режимы округления;
	режимы обработки исключительных 	ситуаций (деление на ноль, переполнение и т. д).
'''

# Создание Decimal чисел
# Создать Decimal число можно из обычного целого числа (int), из числа с плавающей точкой (float) или из строки (str).
print('********************')
from decimal import *

d1 = Decimal(1)
d2 = Decimal(567)
d3 = Decimal(-93)
d4 = Decimal('12345')
d5 = Decimal('52.198')
print(d1, d2, d3, d4, d5, sep='\n')

# При создании Decimal чисел из чисел с плавающей точкой (float) возникают проблемы, так как float числа округляются внутри до ближайшего возможного, а Decimal об этом ничего не знает и копирует содержимое float.
print('********************')
from decimal import *

num = Decimal(0.1)
print(num)
# Не рекомендуется создавать Decimal числа из float чисел. В Decimal попадет уже неправильно округленное число. Создавать Decimal числа нужно из целых чисел, либо из строк!

# Арифметические операции над Decimal числами
print('********************')
from decimal import *

num1 = Decimal('5.2')
num2 = Decimal('2.3')
print(num1 + num2)
print(num1 - num2)
print(num1 * num2)
print(num1 / num2)
print(num1 // num2)
print(num1 ** num2)

# Можно совершать арифметические операции над Decimal и целыми числами (миксовать Decimal и int), но не рекомендуется смешивать их с float.
print('********************')
from decimal import *

num = Decimal('5.2')
print(num + 1)
print(num - 10)
print(num * 2)
print(num ** 4)

# Математические функции
# Decimal числа можно передавать как аргументы функциям, ожидающим float. Они будут преобразованы во float. К примеру, модуль math, оперирующий float числами, может работать и с Decimal числами.
print('********************')
from decimal import *
from math import *

num1 = Decimal('1.44')
num2 = Decimal('0.523')

print(sqrt(num1))
print(sin(num2))
print(log(num1 + num2))

# Тип данных Decimal содержит некоторые встроенные математические методы, возвращающие значения Decimal.
print('********************')
from decimal import *

num = Decimal('10.0')
print(num.sqrt())
print(num.exp())
print(num.ln())
print(num.log10())

# Тип данных Decimal также содержит полезный метод as_tuple() который возвращает кортеж из 3 элементов:
'''
	sign – знак числа (0 для положительного числа и 1 для отрицательного числа);
	digits – цифры числа;
	exponent – значение экспоненты (количество цифр после точки, умноженное на -1)
'''
print('********************')
from decimal import *

num1 = Decimal('-1.4568769017')
num2 = Decimal('0.523')
print(num1.as_tuple())
print(num2.as_tuple())

print('********************')
from decimal import *

num = Decimal('-1.4568769017')
num_tuple = num.as_tuple()

print(num_tuple.sign)
print(num_tuple.digits)
print(num_tuple.exponent)

# Работа с контекстом Decimal чисел
# Базовые параметры Decimal можно посмотреть в его контексте, выполнив функцию getcontext().
print('********************')
from decimal import *

print(getcontext())
# Мы видим здесь, что точность 2828 знаков, округление к ближайшему четному, пределы по экспоненте \pm 999999± 999999, capitals – это про заглавную Е при печати, включенные ловушки – неправильная операция, деление на ноль, переполнение.

# Точность чисел
# Контекстом в Decimal можно управлять, устанавливая свои значения. Например, чтобы управлять точностью Decimal, необходимо изменить параметр контекста prec (от англ. precision – точность). При этом точность вступает в силу только во время арифметических операций, а не при создании самих чисел.
print('********************')
from decimal import *
# устанавливаем точность в 3 знака
getcontext().prec = 3
num = Decimal('3.1415')
print(num)
print(num * 1)
print(num * 2)
print(num / 2)

# Округление чисел
# Округляют числа Decimal с помощью метода quantize(). Этот метод в качестве первого аргумента принимает объект Decimal, указывающий на формат округления.
print('********************')
from decimal import *
# устанавливаем точность числа
getcontext().prec = 4
num = Decimal('3.1415926535')
#  округление до 3 цифр в дробной части
print(num.quantize(Decimal('1.000')))
#  округление до 2 цифр в дробной части
print(num.quantize(Decimal('1.00')))
#  округление до 1 цифр в дробной части
print(num.quantize(Decimal('1.0')))

# Если точность округления установлена в 22 , а формат округления Decimal('1.00'), то возникнет ошибка.
# print('********************')
# from decimal import *
# устанавливаем точность округления
# getcontext().prec = 2
# num = Decimal('3.1415926535')
#  округление до 2 цифр в дробной части
# print(num.quantize(Decimal('1.00')))
# приводит к возникновению ошибки:
# decimal.InvalidOperation: [<class 'decimal.InvalidOperation'>]

# Помимо первого параметра, метод quantize() принимает в качестве второго параметра стратегию округления:
'''
	ROUND_CEILING – округление в направлении бесконечности (Infinity);
	ROUND_FLOOR – округляет в направлении минус бесконечности (- Infinity);
	ROUND_DOWN – округление в направлении нуля;
	ROUND_HALF_EVEN – округление до ближайшего четного числа, число 6.96.9 округлится не до 77, а до 66;
	ROUND_HALF_DOWN – округление до ближайшего нуля;
	ROUND_UP – округление от нуля;
	ROUND_05UP – округление от нуля (если последняя цифра после округления до нуля была бы 0 или 5, в противном случае к нулю).
'''
print('********************')
from decimal import *

num = Decimal('3.456')
print(num.quantize(Decimal('1.00'), ROUND_CEILING))
print(num.quantize(Decimal('1.00'), ROUND_FLOOR))

# Сравнение float и Decimal чисел
# Выбор между типами данных Decimal и float – поиск компромисса в условиях конкретной задачи.
# Если нужно считать очень много (симуляции, физика, графика, игры), имеет смысл отказаться от точности Decimal в пользу скорости и компактности хранения данных float. В бизнесе и финансах считать приходится не так много, но делать это нужно предельно точно, тут имеет смысл посмотреть в сторону Decimal.

# Примечания
# Примечание 1. Decimal числа можно сравнивать между собой, как обычные числа, причем в отличие от float чисел допускается и точное равенство.
print('********************')
from decimal import *

num = Decimal('0.1')
if num*3 == Decimal('0.3'):
    print('YES')
else:
    print('NO')
    
# Примечание 2. Можно сортировать списки с Decimal числами и искать минимум и максимум среди них.
print('********************')
from decimal import *

s = '1.34 3.45 1.00 0.03 9.25'
numbers = [Decimal(i) for i in s.split()]
maximum = max(numbers)
minimum = min(numbers)
numbers.sort()

print(maximum)
print(minimum)
print(numbers)

# Примечание 3. Чтобы не писать каждый раз название типа, можно использовать следующий код
print('********************')
from decimal import Decimal as D

num1 = D('1.5') + D('3.2')
num2 = D('1.4') * D('2.58')
print(num1)
print(num2)