'''
Lines
В таблице n×n некоторые клетки заняты шариками, другие свободны. 
Выбран шарик, который нужно переместить, и место, куда его 
нужно переместить. Выбранный шарик за один шаг перемещается 
в соседнюю по горизонтали или вертикали свободную клетку.

Напишите программу, которая определяет, возможно ли переместить 
шарик из изначальной клетки в заданную, и если возможно, 
то находит путь из наименьшего количества шагов.

Формат входных данных
На вход программе в первой строке подается число n, 
где 2≤n≤40, далее следуют n строк длины n, представляющие собой таблицу. 
Точкой . обозначается свободная клетка, латинской заглавной O — шарик, 
собачкой @ — исходное положение шарика, который должен двигаться, 
латинской заглавной X — конечное положение шарика.

Формат выходных данных
Программа должна вывести YES, если движение возможно, 
или NO, если нет. Если движение возможно, следует также вывести 
исходную таблицу n×n, обозначив на ней путь плюсами +.

Примечание 1. Если движение шарика возможно, конечная точка Х 
также должна быть обозначена плюсом +.

Примечание 2. Если вариантов добраться до конечной точки несколько, 
можно вывести любой.

Примечание 3. Тестовые данные доступны по ссылке.
https://stepik.org/media/attachments/lesson/718107/tests_3019848.zip

Sample Input 1:
5
....X
.OOOO
.....
OOOO.
@....
Sample Output 1:
YES
+++++
+OOOO
+++++
OOOO+
@++++

Sample Input 2:
5
..X..
.....
OOOOO
.....
..@..
Sample Output 2:
NO

Sample Input 3:
5
...X.
.....
O.OOO
.....
....@
Sample Output 3:
YES
..++.
.++..
O+OOO
.++++
....@
'''
# Решение
import copy
n = int(input())
m = [list(input()) for i in range(n)]
rez = copy.deepcopy(m)
for i in range(n):
    for j in range(n):
        if m[i][j] == 'O':
            m[i][j] = 0
        elif m[i][j] == '.':
            m[i][j] = 1
        elif m[i][j] == '@':
            m[i][j] = 1
            pstart = (i, j)
        else:
            m[i][j] = 1
            pend = (i, j)
graf, d, pr = {}, {}, {}
for i in range(n):
    for j in range(n):
        graf[(i,j)] = {}
        d[(i,j)] = 10**6 
        pr[(i,j)] = -1
        if j < n - 1:
            if m[i][j+1] > 0:
                graf[(i,j)][(i,j+1)] = m[i][j+1]
        if i < n - 1:    
            if m[i+1][j] > 0:
                graf[(i,j)][(i+1,j)] = m[i+1][j]
        if j > 0:
            if m[i][j-1] > 0:
                graf[(i,j)][(i,j-1)] = m[i][j-1]
        if i > 0:    
            if m[i-1][j] > 0:
                graf[(i,j)][(i-1,j)] = m[i-1][j]
d[pstart] = 0
q = d.copy()
while q != {}:
    u = min(q, key=q.get)
    del q[u]
    for el, val in graf[u].items():
        if d[el] > d[u] + val:
            d[el] = d[u] + val
            q[el] = d[el]
            pr[el] = u          
if d[pend] == 10**6:
    print('NO')
else:
    print('YES')
    a = pend
    while a != pstart:
        rez[a[0]][a[1]] = '+'
        a = pr[a]
    for i in range(n):
        print(''.join(rez[i]))