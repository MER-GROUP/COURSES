'''
Палиндром наибольшей длины

На вход программы подается строка, содержащая заглавные латинские 
буквы (не обязательно различные). Разрешается переставлять буквы, 
а также удалять некоторые из них. Напишите программу, которая из данных 
букв по указанным правилам составит и выведет палиндром наибольшей длины, 
а если таких палиндромов несколько, то необходимо вывести первый из 
них в алфавитном порядке.

Формат входных данных
На вход программе подается строка, содержащая заглавные латинские буквы

Формат выходных данных
Программа должна вывести палиндром наибольшей длины.

Примечание 1. Палиндром — это строка, которая читается одинаково как 
справа налево, так и слева направо.

Примечание 2. Тестовые данные доступны по ссылке.
https://stepik.org/media/attachments/lesson/1020135/tests_4283413.zip

Sample Input 1:
AAB
Sample Output 1:
ABA

Sample Input 2:
QAZQAZ
Sample Output 2:
AQZZQA

Sample Input 3:
ABCDEF
Sample Output 3:
A

Sample Input 4:
A
Sample Output 4:
A

Sample Input 5:
BB
Sample Output 5:
BB

Sample Input 6:
CCC
Sample Output 6:
CCC

Sample Input 7:
ABAAAABCC
Sample Output 7:
AABCACBAA

Sample Input 8:
ABAAAABCCA
Sample Output 8:
AAABCCBAAA

Sample Input 9:
ABABAB
Sample Output 9:
ABABA
'''
if __name__ == '__main__':
    # строка для анализа
    text = input()
    # массив из 26 нулей (английский алфавит 26 букв)
    counters = [0]*26

    # перебираем строку
    for char in text:
        # считаем одинаковое количество букв в строке
        # и заполняем массив хранения количества одинаковых букв
        counters[ord(char)-ord('A')] += 1

    # определяем переменные для конечного результат
    # и для хранения буквы которая находится в середине слова
    # если слово содержит нечетное количество букв
    result = middle = ''

    # перебираем все буквы английского алфавита
    for i in range(26):
        # заполняем переменную result буквами по следующему правилу
        # берем первую букву и смотрим количество повторений
        # количество повторений делим на 2
        # ответ берем без остатка и конкатенирум result
        # с первой буквой умноженной на ответ без остатка
        # result += chr(i + 65) * (counters[i] // 2)
        result += chr(i + ord('A')) * (counters[i] // 2)
        # запоминаем букву (средний элемент) 
        # которая будет находиться в середине слова
        if middle == '' and counters[i] % 2 == 1:
            # middle = chr(i + 65)
            middle = chr(i + ord('A'))

    # выводим результат
    # перменная result + middle (буква в середине слоыв) 
    # и реверс переменной result
    # print(result, middle, result[::-1], sep='')
    print(result, middle, *reversed(result), sep='')