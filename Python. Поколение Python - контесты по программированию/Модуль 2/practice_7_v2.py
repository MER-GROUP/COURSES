# Вариант №1.
# Честно говоря, эту задачу за отведенное время я решить не успел :(. 
# Но потом оказалось что существует довольно простое решение, если учесть 
# что к каждой клетке ведут всего два пути - из соседних клеток сверху 
# и слева (за исключением клеток в первой строки и столбца, к которым, 
# ведет единственный путь) . Получается, что можно посчитать кратчайшее 
# время для каждой клетки обычном обходом матрицы сверху вниз по строкам. 
# При этом кратчайшее время для каждой клетки выбирается как минимальное 
# из соотвествующих значений в соседних клетках слева и сверху. 
# Для хранения получившихся значений используется та же исходная матрица. 
# Пришлось немного поломать голову над тем, как раздуть матрицу сверху 
# и слева так, чтобы не надо было отдельно писать код для клеток первой 
# строки и первого столбца. В качестве одной из идей используется значение 
# бесконечности math.inf. Например, в позициях стражников выставляется 
# значение math.inf, так что пути, проходящие через эти клетки автоматически 
# уже не окажутся оптимальными. А если в матрице вообще не будет ни одного 
# валидного пути, то в клетке прибытия обязательно окажется значение math.inf, 
# что можно использовать в качестве критерия для определения этого случая. 
# Можно было бы создать отдельную структуру для отслеживания пути назад из 
# конечной точки к старту. Но тот же путь можно отследить на каждом шаге 
# выбирая из соседних клеток, расположенных слева и сверху ту, 
# у которой значение меньше :).

import math

n = int(input())
# создаем матрицу раздутую сверху и слева, так чтобы исключить лишние проверки границ при ее обходе
mtx = [[0] * 2 + [math.inf] * (n - 1)] + [([math.inf] + list(map(int, input()))) for _ in range(n)]

# вычисляем расстояния до каждой клетки на основе двух соседних клеток (сверху и слева)
for i in range(1, n + 1):
    for j in range(1, n + 1):
        mtx[i][j] += (min(mtx[i][j - 1], mtx[i - 1][j]), math.inf)[not mtx[i][j]]

# если требуется math.inf времени - значит пути в конечную клетку просто нет        
if mtx[n][n] == math.inf:
    print('Impossible')
else:      
    res_mtx = [['-'] * n for _ in range(n)]
    
    # отслеживаем оптимальный путь обратно от нижнего правого угла (n - 1, n - 1) 
    # к начальной точке (0, 0)
    res_mtx[0][0] = '#'
    r, c = (n, n)    
    while (r, c) != (1, 1):
        res_mtx[r - 1][c - 1] = '#'
        r, c = (r - 1, c) if mtx[r - 1][c] < mtx[r][c - 1] else (r, c - 1)

    for row in res_mtx:
        print(''.join(row))