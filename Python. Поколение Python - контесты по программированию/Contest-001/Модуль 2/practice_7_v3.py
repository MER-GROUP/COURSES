# Один проход по матрице на решение, и ещё один - на вывод.
# Сначала проходим массив/матрицу от финальной точки к 
# исходной "в обратном направлении" - снизу вверх справа налево. 
# Для каждой ячейки проверяем, откуда в неё выгоднее попадать, 
# снизу или справа - и запоминаем результат проверки в битовом массиве. 
# Далее, для вывода "разматываем" битовую матрицу в обратном направлении. 
# Проходя от ячейки начала маршрута и до финиша слева-направо сверху-вниз - мы 
# уже имеем для каждой клетки информацию, куда двигаться дальше, вниз или вправо.

inf: int = 1000000000
n = int(input())
a = [[inf] * (n + 2)] + [[inf] + [int(c) for c in input()] + [inf] for i in range(n)] + [[inf] * (n + 2)]
a[n][n + 1] = 0
b = [[0 for i in range(n + 2)] for j in range(n + 2)]
for i in range(n, 0, -1):
    for j in range(n, 0, -1):
        if a[i][j] == 0:
            a[i][j] = inf
        if (a[i + 1][j] == inf == a[i][j + 1]):
            a[i][j] = inf
        else:
            if a[i + 1][j] > a[i][j + 1]:
                a[i][j] += a[i][j + 1]
                b[i][j] = 1
            else:
                a[i][j] += a[i + 1][j]
if a[1][1] >= inf:
    print('Impossible')
    exit(0)
j = 1
for i in range(1, n + 1):
    print('-' * (j - 1), end='')
    while j <= n:
        print('#', end='')
        if b[i][j] == 0:
            break
        j += 1
    print('-' * (n - j))