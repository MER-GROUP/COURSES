'''
Ключи к сокровищам мага

Глубоко в заброшенном особняке, на краю темного леса, жил старый зловещий маг. 
Он был знаменит своей злобой и жадностью, и говорили, что он хранил сокровища, 
непостижимые для обычных людей. Многие путники пытались найти его сокровища, 
но все они безнадежно пропадали в тумане и тени леса.

Однажды группа искателей приключений решила отправиться на поиски мага и его сокровищ. 
Они узнали, что маг скрывался в таинственном особняке, где было множество комнат и залов. 
В одной из комнат они нашли массивный железный сундук, запертый на замок. В его глубине 
они решили должно быть сокровища.

Но как открыть этот сундук? Они решили обратиться к мудрецу из соседней деревни. Тот дал 
им подсказку: "В этом сундуке хранятся только наибольшие сокровища. Поэтому вам нужно 
найти k наибольших ключей, чтобы открыть этот сундук".

Вернувшись в особняк, группа искателей использовала эту подсказку, чтобы создать 
функцию top_k_elements(arr, k), которая принимает на вход одномерный массив, 
содержащий только числа, и число k, и возвращает массив из k уникальных наибольших элементов. 
Причем в возвращаемом массиве должны быть все вхождения этих элементов во входном массиве. 
Они назвали эту функцию "Ключи к сокровищам мага".

Разберем тестовый пример 1.  
В массиве 13 16 12 4 13 12 13 20 18 21 3 4 9 9 16 16 4 7 20 17 5 10 8 3 9 17 16 7 3 
15 19 21 17 7 14 8 17 5 11 8 16 21 22 11 8 11 21 17 18 11 19 1 7 18 16, для k = 3 последними тремя 
самыми наибольшим элементами являются 20, 21, 22. Поэтому нужно вернуть numpy массив, 
содержащий все вхождения этих элементов в исходном массиве в том порядке, в котором они 
следуют в исходном массиве. Это массив - [20 21 20 21 21 22 21]. Гарантируется, 
что во входном массиве найдется требуемое количество элементов.

Sample Input:
13 16 12 4 13 12 13 20 18 21 3 4 9 9 16 16 4 7 20 17 5 10 8 3 9 17 16 7 3 15 19 21 17 7 14 8 17 5 11 8 16 21 22 11 8 11 21 17 18 11 19 1 7 18 16
3

Sample Output:
[20 21 20 21 21 22 21]
'''
import numpy as np

def top_k_elements(arr: np, k: int) -> np:
    arr_k = np.sort(a=list(set(arr)))[-k:]
    return arr[arr >= arr_k.min()]

if __name__ == '__main__':
    print(
        top_k_elements(
            np.array(object='13 16 12 4 13 12 13 20 18 21 3 4 9 9 16 16 4 7 20 17 5 10 8 3 9 17 16 7 3 15 19 21 17 7 14 8 17 5 11 8 16 21 22 11 8 11 21 17 18 11 19 1 7 18 16'.split(), dtype=int),
            3
        )
    )